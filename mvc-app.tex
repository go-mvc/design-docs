\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[nonumberlist,nopostdot]{glossaries}
\usepackage{parskip}
\setlength{\parindent}{0pt}

\title{Modern web framework in Golang}
\author{Senior design project (Spring 2016--Fall 2016)}
\date{\today}
\makeglossaries

\begin{document}

\maketitle

\section{Introduction}

The project is to design and build a framework to improve the process of developing web applications in Golang. Golang, also referred to as Go, is an open source programming language developed at Google that emphasizes concurrency and safety. Since the languageâ€™s inception in 2009, Go has been quickly gaining popularity for use on high-performance, concurrent servers.

The web framework to be designed addresses the need of web developers to quickly bootstrap and reliably maintain web applications in Go. A primary goal of the framework is to integrate with technologies such as Docker to provide first-class support for painless and rapid application deployment. The framework will provide developers a command-line \textsc{api} to generate extensible boilerplate code to quickly start application development.

Another motivation for the framework is to facilitate the use of contemporary design patterns such as unidirectional data flow, function decorators, and database abstraction. These paradigms are popular and effective tools for web application development.

The project involves the challenges of architecting a large software application; routing \textsc{http} requests concurrently and securely; linking actions, datastores, and views; and providing a unified interface for database queries. The components of the application will be tested continuously throughout the development cycle using unit tests and continuous integration (\textsc{ci}). Framework documentation and an example web application showcasing the framework will also be included for user reference. 

\section{Web frameworks}

A number of frameworks have emerged to meet the need of building fast, maintainable, and reliable websites. The Model View Controller (\textsc{mvc}) architecture implemented in Ruby on Rails and the Flux-React pattern in JavaScript are of primary interests to our project.
 
The \textsc{mvc} architecture separates a web application into three interconnected parts: Models, Views, and Controllers. By this separation, the internal representations of information are separated from the ways that the user interacts with the information. The separation helps programmers visualize the interactions between data components and better organize information flow. By adopting an \textsc{mvc} framework, a web developer hopes to model user data, control the data flow between the server and the user, and present information to users in different views such as \textsc{html, json}, etc. The separation of concerns helps write maintainable code.

Flux is a data flow architecture based on action-driven, unidirectional data flow. Actions generated by the server are routed by the dispatcher, which connects the datastore and the views as shown in Figure 1. The dispatcher is a singleton that directs the flow of data and ensures that updates do not cascade by invoking callbacks in the correct order.\footnote{https://facebook.github.io/react/blog/2014/05/06/flux.html} User interactions in the views generate actions that are fed back into the dispatcher like server updates, as shown in Figure 2.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{flux.pdf}
\caption{Server updates in Flux \newline{}(adapted from: \texttt{https://facebook.github.io/flux/docs/overview.html})}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{flux__1_.pdf}
\caption{User interaction in Flux \newline{}(adapted from: \texttt{https://facebook.github.io/flux/docs/overview.html})}
\end{figure}

% TODO: conclusion paragraph

\subsection{Scalability and the need for frameworks in more languages}
 
Most of the popular frameworks that have emerged in the past decade are made for dynamically typed languages. They include Ruby on Rails (for the Ruby programming language), Django (for Python), and Sails.js (for JavaScript). However, large projects written in scripting languages such as Ruby, Python, and JavaScript without type-checking are unwieldy to maintain and difficult to scale, as many companies such as Twitter have discovered.\footnote{{https://blog.twitter.com/2011/the-engineering-behind-twitter-s-new-search-experience}}

As a result, more performant languages such as Java, Scala, and C\texttt{++} continue to be used by large companies for their backend infrastructures. Go is an upcoming language that belongs to this category.

\subsection{Golang frameworks}

Go currently has a few third-party libraries that facilitate developing web applications. Most Go web frameworks are lightweight \textsc{mvc} libraries. Gorilla and Martini are two such libraries that make a conscious effort to be lightweight (in fact, Gorilla is just a collection of discrete packages). Beego and Revel are other Golang based \textsc{mvc} framework solutions. 

The new framework will enable developers to structure applications using maintainable design patterns and write composable middleware functions. The end result of this project will be a batteries-included web application development library that is more maintainable and faster to deploy than existing solutions.

\section{Technical details}

The project will be an exercise in concurrent architecture, \textsc{http} routing, \textsc{rest} design, web security, database driver development, web application development, \textsc{api} design, and open-source development. The project will be developed using the latest stable release of Go, which currently is \texttt{go1.6}. 

\subsection{Components}

\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{app-structure.pdf}
\caption{Major framework components}
\end{figure}

The major components of the framework are:

\begin{itemize}
    \item \textbf{The base of the framework}: This includes code for generating the file structure for the requested actions, dispatchers, reducers, datastore models, and views. It also involves the logic and rules for maintaining the relationships between these components through the lifetime of the application.
    \item \textbf{Command-line interface}: The command-line application will provide the developer access to the framework's \textsc{api}. It will allow developers to start and stop the web server; create new actions, data models, and views; configure their application; and deploy their application.
    \item \textbf{Server, router, sessions}: The framework will come with a built-in \textsc{http} server to serve applications. The plan is to make components easily swappable, so developers can choose to drop in their own \textsc{http} server, mux, or router implementation during production if needed. This would rely on Go's \texttt{net/http} package or on faster alternatives such as \texttt{valyala/fasthttp}.\footnote{The open source package available at {https://github.com/valyala/fasthttp} claims to be up to 10x faster than the built-in http package} Other related components include the router and a cookies and sessions manager. 
    \item \textbf{Database interface}: Models will need to persist on disk. Developing a domain specific query language (\textsc{dsl}) will abstract away the details of the underlying database from application developers. The interface will provide a unified way of accessing the database and make it possible to replace the underlying database safely without significant developer effort.
    \item \textbf{Templating engine}: This is required to render model data on \textsc{html} views. As of now, Go's \texttt{html/template} package appears to be a good choice---providing a good balance of performance, familiarity to users, and support for expressive programming logic directly in the view templates.
\end{itemize}

\vspace{1em}

\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{runtime-example.pdf}
\caption{Framework runtime: handling a simple request}
\end{figure}

\subsection{Features}

The framework will have the following features:

\begin{itemize}
	\item Pre-configured sane default values that make it easy for developers to get a basic application running quickly.
	\item Single command deployment to Docker and container management with Kubernetes.
    \item Deployment to Heroku, Digital Ocean, and Amazon Web Services.
    \item Support for the decorator pattern and middleware functions, similar to Koa.js.
    \item Improved support for popular in-memory datastores such as Redis.
	\item Support for third-party online data persistence solutions such as Firebase, Google Cloud DataStore, and AppEngine DataStore.
    \item Built-in authentication support with common log-in providers such as Google, Gravatar, Twitter, and GitHub (undecided). 
    % COMMENT:nishanths: I wrote "(undecided)". Feel free to remove/reword or remove the entire list item.
    \item Testing and load generation tools.
\end{itemize}

\subsection{Lines of code}

The team anticipates that the project will require around 25,000 lines of code.

\subsection{Testing}

Code coverage is an important component of the project. Unit tests will be written when appropriate. The code repositories are currently configured to use Wercker, a continuous integration and build system service, to trigger builds and tests on each commit. Testing frameworks will be added as necessary. Currently, ginkgo---a BDD testing framework---is the primary candidate.

\section{Challenges}

From initial discussions, the team currently expects these challenges:

\begin{itemize}
    \item \textbf{Internalizing the Flux pattern}: The team currently has limited familiarity with the Flux pattern. Members will need to orient themselves with basic conventions of the pattern before architecting the framework.
    \item \textbf{Architecting the framework}: Development of the framework components will be delegated to team members to work in parallel. Team members will need to modularize code in a manner that allows proper connecting of components. The framework would need to be architected in a manner that is maintainable and flexible enough to modify on the long term.
    \item \textbf{Connecting related actions, data, and views}: Naming conventions (Ã  la Rails style) or developer configurable options should exist for mapping relations between routes, actions, data, and views. The pros and cons of either approach need to be evaluated. The implementation would need to be predictable and ambiguity free, as this is a part of the framework's logic that will be used on every incoming request for standard applications.
\end{itemize}

Thoughtful design decisions in the initial stages are important for the success of the project. Research on the strong and weak points of existing \textsc{mvc} frameworks in Go and implementations of the Flux pattern in other languages is expected. Careful problem scoping will also help address most issues.

\section{Costs}

The team does not anticipate major financial costs in the development of the framework. 

\section{Conclusion}

The team is currently in the design phase---researching existing designs, evaluating prospective tools, and formulating the architecture for the framework. Feedback and suggestions are always welcome.\\

Contact for questions, comments regarding this proposal: 
\vspace{1em}
\begin{itemize}
    \item Joshua Dong $\langle jdong42@gmail.com \rangle$
    \item Brad Gray $\langle bpgray@utexas.edu \rangle$
    \item *Rahul Jaisimha $\langle rahul@jaisimha.com \rangle$
	\item Salim Memon $\langle salim.memon@utexas.edu  \rangle$
    \item *Taiyi Ouyang $\langle taiyi.o@utexas.edu \rangle$
    \item *Nishanth Shanmugham $\langle nishanths@utexas.edu \rangle$
\end{itemize}
\vspace{1em}
Students marked with * are honors students.

% Glossary
\newglossaryentry{api}
{
  name=API,
  description={
    Application Programming Interface. Defines an interface that software programs can use to interact with each other.
 } 
}

\newglossaryentry{mvc}
{
  name=MVC,
  description={
    Model View Controller. A design paradigm in software engineering. Popular for the design of web applications.
  }
}

\newglossaryentry{flux}
{
  name=Flux (design pattern),
  description={
    A design paradigm in software engineering, popularized by JavaScript client-side frameworks such as Flux and Redux. Emphasizes unidirectional data flow for better maintainability.
  }
}

\newglossaryentry{ci}
{
  name=CI,
  description={
    Continuous Integration. A software development strategy in which code that is committed is tested and integrated using automation tools to catch errors early.
  }
}

\newglossaryentry{http}
{
  name=HTTP,
  description={
    Hypertext Transfer Protocol. The network protocol that is the basis of communication on the World Wide Web.
  }
}

\newglossaryentry{rest}
{
  name=REST,
  description={
    Representational State Transfer. An architectural style for web application design and resource handling. RESTful systems emphasize statelessness and generally communicate over HTTP.
  }
}

\newglossaryentry{rubyonrails}
{
  name=Ruby on Rails,
  description={
    Ruby on Rails, or Rails for short, is an \textsc{mvc} web development framework for the Ruby programming language.
  }
}

\newglossaryentry{sailsjs}
{
  name=Sails.js,
  description={
    Sails.js is an \textsc{mvc} web development framework for the Node.js JavaScript runtime.
  }
}

\newglossaryentry{django}
{
  name=Django,
  description={
    Django is an \textsc{mvc} web development framework for the Python programming language.
  }
}

\newglossaryentry{digitalocean}
{
  name=Digital Ocean,
  description={
    A cloud services infrastructure provider.
  }
}

\newglossaryentry{firebase}
{
  name=Firebase,
  description={
    An online, easy-to-configure database service company.
  }
}

\newglossaryentry{redis}
{
  name=Redis,
  description={
    A high-performance, in-memory data structure store commonly used for caching. 
  }
}

\newglossaryentry{appengine}
{
  name=AppEngine,
  description={
    A web application hosting platform from Google.
  }
} 

\newglossaryentry{heroku}
{
  name=Heroku,
  description={
    A web application hosting company.
  }
}


\newglossaryentry{docker}
{
  name=Docker,
  description={
    Open source framework for packaging, distributing, and deploying applications.
  }
}

\newglossaryentry{kubernetes}
{
  name=Kubernetes,
  description={
    Open source software for managing containerized applications such as those running on Docker.
  }
}

\newglossaryentry{singleton}
{
  name=Singleton (software engineering),
  description={
    A type of class for which only one instance of the class exists throughout the lifetime of the program.
 } 
}

\newglossaryentry{koajs}
{
  name=Koa.js,
  description={
    A JavaScript web framework that emphasizes the use of middleware functions.
 } 
}

\newglossaryentry{BDD}
{
  name=BDD,
  description={
    Behavior Driven Development. Software development process in which tests and expected behavior for features are written before the code that implements those features.
 } 
}

\newglossaryentry{json}
{
	name=JSON,
    description={
    	JavaScript Object Notation. Data-serialization and data-interchange format, officially specified in RFC7159.
    }
}

\newglossaryentry{html}
{
	name=HTML,
    description={
    	HyperText Markup Language. A programming language primarily used for creating web pages.
    }
}

\glsaddall
\printglossaries

\end{document}
